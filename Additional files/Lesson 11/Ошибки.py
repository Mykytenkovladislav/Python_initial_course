#  Ошибки в коде программы можно разделить на три группы:

#  1) Синтаксические ошибки (приводит к немедленному завершению программы)
#  2) Ошибки времени выполнения (runtime errors) (тоже приводит к немедленному завершению программы)
#  3) Логические ошибки (не приводят к завершению программы)

# 1) Синткасические ошибки
for i in range(10):# тут все просто - они происходят тогда, когда вы используете НЕ валидный синтаксис python
    pass
# Это ошибка выглядит так:
# SyntaxError: invalid syntax


# 2) Ошибки времени выполнения
# Этих ошибок очень много:
# - ZeroDivisionError (при попытке деления на 0)
# - ValueError (пример: вызов функции с неправльным типом аргумента)
# - AttributeError (при попытке обратиься к не существующему методу|атрибуту объекта)
# - ImportError (не удалось провести операцию импорт)
# - IndexError (при неверном указании индекса при срезе)
# - KeyError (При попытке получить объект по несуществующему ключу)
# - NameError (при попытке обратиться к не существующему идентификатору)
# - UnicodeError (ошибка связанная с кодировкой|раскодировкой строк)
# - TypeError (при попытке провести операцию с объектом, тип которого не поддерживает такие операции)
# - Exception (обозначает любую ошибку, по сути - является родителем всем другим типам ошибок
# )



# Если мы думаем что в какой-то части программы может произойти ошибка -
# мы используем следующюю контсрукцию
try:
    n = 42 / 0 # операция во время которой может быть вызвана ошибка
except Exception as e:  # после except - тип ошибки который мы ожидаем
    n = 0
    print('Произошла ошиибка!', e)
else:
    print('Тут не произошло ошибки')
finally:
    print('В конце концов это будет выполнено')


# Логические ошибки
# Причина - несоответвие правильной логике программы


# Давольно часто просто обработать ошибку в функции - плохая затея.
# Необходимо, например, произвести логгирование этой ошибки,
# и далее передать эту ошибку тому кто выззвал функцию.

# В таком случае обычно делают так:

def x(*args):
    try:
        x = args[4]
    except IndexError as e:
        print("Возникла ошибка!")
        raise # Эта команда опятть вызовет то исключение, которые вы споймали!
    # Таким образом вы обработали ошибку в месте ее возниковения,
    # и дали знать тому кто вызвал функцию о том что произошла ошибка!


# Так же можно делать так:
def x1(*args):
    if len(args) < 5:
        raise ValueError("Слишком мало аргументов!")
    return args[4]


# Кроме механизма возбуждения ошибок, так же есть механизм утверждений:
def x2(*args):
    assert len(args) < 5, "Слишком мало аргументов!"
    return args[4]

# Не соответствие утверждению вызввет AssertionError с сообщением которое идет после этого утверждения.
# Не стоит использовать утверждения в реально работающей программе как механизм вызова исключений,
# т.к. интерпритатор можно включить в таком режиме, что все утверждения будут игнорироваться



